import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

public class Agent {

	private String name;
	private Portfolio portfolio;
	private ArrayList <Stock> market;
	private Map<Stock, String> plannedActions;
//	private Map<Stock, ArrayList<Double>> priceHistory;
	private Map<Stock, Double> confidence;  // rational confidence for each stock based on its perfomance
	
	// Behavioral AI traits
	private double riskTolerance;  // 0.0 (safe) to 1.0 (bold); skip if trend is not strong enough
	private double lossAversionFactor;  // >1 (losses weigh more than gains); <1 (gains weigh more than losses)
	private double herdBehaviorBias;  // 0 (independent) to 1 (copies crowd)
	private double overConfidenceBias;  // 0 (humble) to 1 (cocky)
	private double emotionalNoiseLevel;  // range of randomness
	

	public Agent(String name, Portfolio portfolio, ArrayList<Stock> market) {
		this.name = name;
		this.portfolio = portfolio;
		this.market = market;
//		priceHistory = new HashMap<>();
		plannedActions = new HashMap<>();
		confidence = new HashMap<>();
		
		// Behavioral traits
		riskTolerance = Math.random();  // 0.2 to 0.8
		lossAversionFactor = 1.2 + 0.8 * Math.random();  // 1.2 to 2.0
		herdBehaviorBias = 0.5 * Math.random();  // 0 to 0.5
		overConfidenceBias = 0.5 * Math.random();  // 0 to 0.5
		emotionalNoiseLevel = 0.5 + 0.1 * Math.random();  // 0.5 to 0.15
	}	
	
	public Portfolio getPortfolio() {
		return portfolio;
	}

	
	public String getName() {
		return name;
	}
	
	
	public void makeDecision(Stock s) { // Buy low, sell high
		int numPrices = s.getPriceHistory().size();
		
		if (numPrices > 5) {
			for (int i = numPrices-5; i < numPrices; i++) {   // get average of last 3 prices
				double p = s.getPriceHistory().get(i);
			}
		}
		else {
			for (int i = 0; i < numPrices; i++) {   // get average of last 3 prices
				double p = s.getPriceHistory().get(i);
			}
		}
		
		confidence.put(s, calculateBehavioralConfidence(s));
		
		if (confidence.get(s) > 0.6) {
			plannedActions.put(s, "BUY");
		}
		else if (confidence.get(s) < 0.4) {
			plannedActions.put(s, "SELL");
		}
		else {
			plannedActions.put(s, "HOLD");
		}
		
	}
		
	
	private double calculateBehavioralConfidence(Stock s) {
		double percentChange = s.getPercentChange();
		
		double baseConfidence = percentChange * 10 + 0.5;
		baseConfidence = Math.max(0,  Math.min(1,  baseConfidence));
		
		// Loss Aversion or Over confidence:
		if (percentChange < 0) {
			baseConfidence *= lossAversionFactor;
		}
		else {
			baseConfidence *= (1 + overConfidenceBias);
		}
		
		// Risk Tolerance (ignore small changes if low risk tolerance):
		if (Math.abs(percentChange) < (0.01 + (1 - riskTolerance) * 0.05)) {
			return 0.5 + randomNoise();
		}
		
		// Herd Influence:
		double herdSentiment = getFakeMarketSentiment(s);
		baseConfidence += herdSentiment * herdBehaviorBias;
		
		baseConfidence += randomNoise();
		
		return Math.max(0, Math.min(1, baseConfidence));
	}


	private double getFakeMarketSentiment(Stock s) {
		return Math.random() * 2 - 1;  // range -1 to 1
	}


	private double randomNoise() {
		return (Math.random() * 2 -1) * emotionalNoiseLevel;
	}

	
	public Map<Stock, String> getPlannedActions() {
		return plannedActions;
	}

	
	public void decideAndAct(ArrayList<Stock> stockMarket) {
		for (Stock s: market) {
			makeDecision(s);
		
			double currentPrice = s.getPrice();
			double conf = confidence.get(s);
			
			String decision = plannedActions.get(s);
			int quant = 0;
			
			switch (decision) {
			case "BUY":
				int affordable = (int)(portfolio.getCashBalance() / currentPrice);
				
				// Adjust quantity based on confidence, risk, and overconfidence
				quant = (int)(affordable * conf * riskTolerance * (1 + overConfidenceBias));
				
				// Buy at least 1 if highly confident
				if (conf > 0.85 && quant == 0 && affordable > 0) {
					quant = 1;
				}
				
				if (quant > 0) {
					portfolio.buyStock(s, quant);
				}
				break;
				
			case "SELL":
				int own = portfolio.getHoldings().getOrDefault(s, 0);
				
				// Adjust quantity based on inverse confidence and loss aversion
				quant = (int)(own * (1 - conf) * lossAversionFactor * (1 + emotionalNoiseLevel));
				
				// Sell all if extremely low confidence
				if (conf < 0.2 && own > 0) {
					quant = own;
				}
				
				// Cap quantity at what you own
				quant = Math.min(quant, own);
				
				if (quant > 0) {
					portfolio.sellStock(s, quant);
				}
				break;
			
			default:
				// if action == HOLD
				break;
			}
			
			// System.out.println("Agent decision: " + decision + " " + quant + " shares of " + s.getName());
			
		}
	}
}
